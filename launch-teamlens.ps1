#!/usr/bin/env pwsh

<#
.SYNOPSIS
    Script de lanzamiento para la aplicaci√≥n TeamLens (Backend)
    
.DESCRIPTION
    Este script automatiza el proceso de instalaci√≥n, compilaci√≥n y ejecuci√≥n
    tanto del frontend (Angular) como del backend (Node.js/TypeScript) de TeamLens.
    Est√° dise√±ado para entornos de desarrollo local y debe ejecutarse desde 
    la carpeta del backend (backend_teamlens).
    
.AUTHOR
    DevOps Team - TeamLens Project
    
.VERSION
    2.0.0
    
.NOTES
    Requisitos previos:
    - Node.js versi√≥n 18+ instalado
    - MongoDB ejecut√°ndose en localhost:27017
    - Puertos 4200 (frontend) y 3000 (backend) disponibles
    - Frontend ubicado en directorio hermano: ../frontend_teamlens
    
.EXECUTION
    Ejecutar desde la carpeta backend_teamlens:
    .\launch-teamlens.ps1
#>

param(
    [switch]$SkipInstall = $false,  # Omitir instalaci√≥n de dependencias
    [switch]$CleanInstall = $false, # Forzar reinstalaci√≥n limpia
    [switch]$Verbose = $false,      # Salida detallada
    [switch]$BackendOnly = $false   # Solo iniciar backend (sin frontend)
)

# Configuraci√≥n de colores para output profesional
$ErrorColor = "Red"
$SuccessColor = "Green" 
$InfoColor = "Cyan"
$WarningColor = "Yellow"

# Rutas de los proyectos (relativas desde backend_teamlens)
$BackendPath = "."                      # Directorio actual (backend_teamlens)
$FrontendPath = "..\frontend_teamlens"  # Directorio hermano
$RootPath = Get-Location

# Variables de configuraci√≥n
$BackendPort = 3000
$FrontendPort = 4200

function Write-ColoredOutput {
    param(
        [string]$Message,
        [string]$Color = "White",
        [string]$Prefix = ""
    )
    
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host "[$timestamp] $Prefix$Message" -ForegroundColor $Color
}

function Test-ExecutionContext {
    Write-ColoredOutput "üîç Validando contexto de ejecuci√≥n..." $InfoColor
    
    # Verificar que estamos en la carpeta correcta (debe contener package.json del backend)
    if (-not (Test-Path "package.json")) {
        Write-ColoredOutput "‚ùå Error: No se encontr√≥ package.json en el directorio actual" $ErrorColor
        Write-ColoredOutput "   Este script debe ejecutarse desde la carpeta backend_teamlens" $WarningColor
        exit 1
    }
    
    # Verificar que el package.json corresponde al backend
    $packageContent = Get-Content "package.json" | ConvertFrom-Json
    if ($packageContent.name -ne "node3ts") {
        Write-ColoredOutput "‚ùå Error: Este no parece ser el directorio del backend de TeamLens" $ErrorColor
        Write-ColoredOutput "   Aseg√∫rese de ejecutar desde la carpeta backend_teamlens" $WarningColor
        exit 1
    }
    
    Write-ColoredOutput "‚úÖ Contexto de ejecuci√≥n v√°lido: Backend TeamLens" $SuccessColor
    
    # Verificar si existe el frontend (solo advertencia, no error)
    if (-not $BackendOnly -and -not (Test-Path $FrontendPath)) {
        Write-ColoredOutput "‚ö†Ô∏è  Advertencia: No se encontr√≥ el directorio del frontend en $FrontendPath" $WarningColor
        Write-ColoredOutput "   El script continuar√° solo con el backend" $InfoColor
        Write-ColoredOutput "   Para incluir frontend, aseg√∫rese de que est√© en: $FrontendPath" $InfoColor
        $script:BackendOnly = $true
    } elseif (-not $BackendOnly) {
        Write-ColoredOutput "‚úÖ Frontend detectado en: $FrontendPath" $SuccessColor
    }
}

function Test-Prerequisites {
    Write-ColoredOutput "üîç Verificando prerequisitos del sistema..." $InfoColor
    
    # Verificar Node.js
    try {
        $nodeVersion = node --version 2>$null
        if ($nodeVersion) {
            Write-ColoredOutput "‚úÖ Node.js detectado: $nodeVersion" $SuccessColor
        } else {
            throw "Node.js no encontrado"
        }
    }
    catch {
        Write-ColoredOutput "‚ùå Error: Node.js no est√° instalado o no est√° en el PATH" $ErrorColor
        Write-ColoredOutput "   Instale Node.js desde https://nodejs.org/" $WarningColor
        exit 1
    }
    
    # Verificar npm
    try {
        $npmVersion = npm --version 2>$null
        Write-ColoredOutput "‚úÖ npm detectado: v$npmVersion" $SuccessColor
    }
    catch {
        Write-ColoredOutput "‚ùå Error: npm no est√° disponible" $ErrorColor
        exit 1
    }
    
    # Verificar y liberar puertos autom√°ticamente
    $portsToCheck = @($BackendPort)
    if (-not $BackendOnly) {
        $portsToCheck += $FrontendPort
    }
    
    foreach ($port in $portsToCheck) {
        $connections = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
        
        if ($connections) {
            Write-ColoredOutput "‚ö†Ô∏è  Puerto $port ocupado. Liberando autom√°ticamente..." $WarningColor
            
            foreach ($conn in $connections) {
                if ($conn.State -eq "Listen") {
                    try {
                        $process = Get-Process -Id $conn.OwningProcess -ErrorAction SilentlyContinue
                        if ($process) {
                            Write-ColoredOutput "üõë Terminando proceso PID:$($process.Id) ($($process.ProcessName)) en puerto $port" $InfoColor
                            $process.Kill()
                            Write-ColoredOutput "‚úÖ Proceso terminado exitosamente" $SuccessColor
                        }
                    }
                    catch {
                        Write-ColoredOutput "‚ö†Ô∏è  No se pudo terminar proceso en puerto $port" $WarningColor
                    }
                }
            }
            
            # Esperar un momento para que el puerto se libere
            Start-Sleep -Seconds 2
            
            # Verificar que el puerto est√° libre
            $stillInUse = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
            if ($stillInUse) {
                Write-ColoredOutput "‚ùå No se pudo liberar el puerto $port" $ErrorColor
            } else {
                Write-ColoredOutput "‚úÖ Puerto $port liberado correctamente" $SuccessColor
            }
        } else {
            Write-ColoredOutput "‚úÖ Puerto $port disponible" $SuccessColor
        }
    }
}

function Setup-EmailService {
    Write-ColoredOutput "üìß Configurando servicio de email para desarrollo..." $InfoColor
    
    $envPath = ".env-dev"  # Ahora buscamos en el directorio actual
    
    if (Test-Path $envPath) {
        $envContent = Get-Content $envPath
        
        # Verificar si las credenciales de email son las de prueba
        $emailUser = ($envContent | Where-Object { $_ -like "EMAIL_USER=*" }) -replace 'EMAIL_USER=', '' -replace '"', ''
        $emailPass = ($envContent | Where-Object { $_ -like "EMAIL_PASSWORD=*" }) -replace 'EMAIL_PASSWORD=', '' -replace '"', ''
        
        if ($emailUser -eq "dalfamosni@mail.com" -or $emailPass -eq "1234") {
            Write-ColoredOutput "‚ö†Ô∏è  Detectadas credenciales de email de prueba" $WarningColor
            Write-ColoredOutput "üìß Forzando modo debug de email..." $InfoColor
            
            # Configurar para forzar debug de emails
            $newEnvContent = $envContent | ForEach-Object {
                if ($_ -like "EMAIL_USER=*") {
                    'EMAIL_USER="test@teamlens-dev.local"'
                } elseif ($_ -like "EMAIL_PASSWORD=*") {
                    'EMAIL_PASSWORD="invalid-password-force-error"'
                } else {
                    $_
                }
            }
            
            # Forzar configuraci√≥n que cause errores para mostrar emails en consola
            $hasEmailDebug = $envContent | Where-Object { $_ -like "*EMAIL_DEBUG*" }
            if (-not $hasEmailDebug) {
                $newEnvContent += ""
                $newEnvContent += "# Forzar debug de email - emails aparecer√°n en consola"
                $newEnvContent += 'EMAIL_DEBUG="true"'
                $newEnvContent += 'NODE_ENV="development"'
            }
            
            $newEnvContent | Set-Content $envPath
            Write-ColoredOutput "‚úÖ Email configurado para debug (errores mostrar√°n contenido)" $SuccessColor
            Write-ColoredOutput "üìù Los emails aparecer√°n en la consola cuando fallen" $InfoColor
        } else {
            Write-ColoredOutput "‚úÖ Configuraci√≥n de email v√°lida detectada" $SuccessColor
        }
    } else {
        Write-ColoredOutput "‚ö†Ô∏è  Archivo .env-dev no encontrado, usando configuraci√≥n por defecto" $WarningColor
    }
}

function Install-Dependencies {
    param([string]$ProjectPath, [string]$ProjectName)
    
    $currentLocation = Get-Location
    Set-Location $ProjectPath
    
    if ($CleanInstall -and (Test-Path "node_modules")) {
        Write-ColoredOutput "üßπ Limpiando instalaci√≥n previa de $ProjectName..." $InfoColor
        Remove-Item -Recurse -Force "node_modules" -ErrorAction SilentlyContinue
        Remove-Item -Force "package-lock.json" -ErrorAction SilentlyContinue
    }
    
    if (-not (Test-Path "node_modules") -or $CleanInstall) {
        Write-ColoredOutput "üì¶ Instalando dependencias de $ProjectName..." $InfoColor
        
        $installArgs = @("install")
        if ($Verbose) { $installArgs += "--verbose" }
        
        $installProcess = Start-Process -FilePath "cmd.exe" -ArgumentList (@("/c", "npm") + $installArgs) -NoNewWindow -PassThru -Wait
        
        if ($installProcess.ExitCode -eq 0) {
            Write-ColoredOutput "‚úÖ Dependencias de $ProjectName instaladas correctamente" $SuccessColor
        } else {
            Write-ColoredOutput "‚ùå Error instalando dependencias de $ProjectName" $ErrorColor
            Set-Location $currentLocation
            exit 1
        }
    } else {
        Write-ColoredOutput "‚úÖ Dependencias de $ProjectName ya est√°n instaladas" $SuccessColor
    }
    
    Set-Location $currentLocation
}

function Build-Backend {
    Write-ColoredOutput "üî® Compilando backend TypeScript..." $InfoColor
    
    # Ya estamos en el directorio del backend, no necesitamos cambiar
    
    # Limpiar build anterior si existe
    if (Test-Path "build") {
        Remove-Item -Recurse -Force "build" -ErrorAction SilentlyContinue
    }
    
    $buildProcess = Start-Process -FilePath "cmd.exe" -ArgumentList @("/c", "npm", "run", "tsc") -NoNewWindow -PassThru -Wait
    
    if ($buildProcess.ExitCode -eq 0) {
        Write-ColoredOutput "‚úÖ Backend compilado exitosamente" $SuccessColor
    } else {
        Write-ColoredOutput "‚ùå Error compilando el backend" $ErrorColor
        Write-ColoredOutput "‚ö†Ô∏è  Revise los errores de TypeScript arriba" $WarningColor
        Write-ColoredOutput "üí° Puede continuar con --SkipBuild si los errores no son cr√≠ticos" $InfoColor
        exit 1
    }
}

function Start-Services {
    Write-ColoredOutput "üöÄ Iniciando servicios de TeamLens..." $InfoColor
    
    # Array para almacenar los procesos
    $processes = @()
    $currentLocation = Get-Location
    
    try {
        # Iniciar Backend (ya estamos en el directorio correcto)
        Write-ColoredOutput "üñ•Ô∏è  Iniciando backend en puerto $BackendPort..." $InfoColor
        $backendProcess = Start-Process -FilePath "cmd.exe" -ArgumentList @("/c", "npm", "run", "dev") -PassThru
        $processes += $backendProcess
        
        # Esperar un momento para que el backend se inicie
        Start-Sleep -Seconds 3
        
        # Iniciar Frontend solo si no es BackendOnly y existe
        if (-not $BackendOnly -and (Test-Path $FrontendPath)) {
            Write-ColoredOutput "üåê Iniciando frontend en puerto $FrontendPort..." $InfoColor
            Set-Location $FrontendPath
            $frontendProcess = Start-Process -FilePath "cmd.exe" -ArgumentList @("/c", "npm", "start") -PassThru
            $processes += $frontendProcess
            Set-Location $currentLocation
        } elseif ($BackendOnly) {
            Write-ColoredOutput "‚è≠Ô∏è  Modo solo backend: omitiendo frontend" $InfoColor
        }
        
        Write-ColoredOutput "‚úÖ Servicios iniciados correctamente" $SuccessColor
        Write-ColoredOutput "üîó Backend:  http://localhost:$BackendPort" $InfoColor
        if (-not $BackendOnly -and (Test-Path $FrontendPath)) {
            Write-ColoredOutput "üîó Frontend: http://localhost:$FrontendPort" $InfoColor
        }
        Write-ColoredOutput "" 
        Write-ColoredOutput "üìã Para detener los servicios, presione Ctrl+C" $WarningColor
        Write-ColoredOutput "üìä Monitoreando procesos..." $InfoColor
        
        # Monitorear procesos
        while ($true) {
            $aliveProcesses = $processes | Where-Object { -not $_.HasExited }
            
            if ($aliveProcesses.Count -eq 0) {
                Write-ColoredOutput "‚ö†Ô∏è  Todos los procesos han terminado" $WarningColor
                break
            }
            
            Start-Sleep -Seconds 5
        }
        
    }
    catch {
        Write-ColoredOutput "‚ùå Error iniciando servicios: $($_.Exception.Message)" $ErrorColor
    }
    finally {
        # Cleanup: Terminar procesos si a√∫n est√°n ejecut√°ndose
        Write-ColoredOutput "üõë Terminando servicios..." $InfoColor
        
        foreach ($process in $processes) {
            if (-not $process.HasExited) {
                try {
                    $process.Kill()
                    Write-ColoredOutput "‚úÖ Proceso $($process.Id) terminado" $SuccessColor
                }
                catch {
                    Write-ColoredOutput "‚ö†Ô∏è  No se pudo terminar el proceso $($process.Id)" $WarningColor
                }
            }
        }
        
        Set-Location $currentLocation
    }
}

function Show-Header {
    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor $InfoColor
    Write-Host "‚ïë                     TEAMLENS LAUNCHER                        ‚ïë" -ForegroundColor $InfoColor  
    Write-Host "‚ïë                  Sistema de Gesti√≥n de Equipos               ‚ïë" -ForegroundColor $InfoColor
    Write-Host "‚ïë                                                              ‚ïë" -ForegroundColor $InfoColor
    Write-Host "‚ïë  üöÄ Lanzador Backend para Entorno de Desarrollo             ‚ïë" -ForegroundColor $InfoColor
    Write-Host "‚ïë  üìÇ Ejecut√°ndose desde: backend_teamlens                    ‚ïë" -ForegroundColor $InfoColor
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor $InfoColor
    Write-Host ""
}

# ===============================
# EJECUCI√ìN PRINCIPAL
# ===============================

try {
    Show-Header
    
    # Verificar contexto de ejecuci√≥n
    Test-ExecutionContext
    
    # Verificar prerequisitos del sistema
    Test-Prerequisites
    
    # Configurar servicio de email para desarrollo
    Setup-EmailService
    
    # Instalar dependencias si es necesario
    if (-not $SkipInstall) {
        Install-Dependencies -ProjectPath $BackendPath -ProjectName "Backend"
        
        if (-not $BackendOnly -and (Test-Path $FrontendPath)) {
            Install-Dependencies -ProjectPath $FrontendPath -ProjectName "Frontend"
        }
    } else {
        Write-ColoredOutput "‚è≠Ô∏è  Omitiendo instalaci√≥n de dependencias" $InfoColor
    }
    
    # Compilar backend
    Build-Backend
    
    # Iniciar servicios
    Start-Services
    
}
catch {
    Write-ColoredOutput "üí• Error cr√≠tico en el script: $($_.Exception.Message)" $ErrorColor
    Write-ColoredOutput "üìç L√≠nea: $($_.InvocationInfo.ScriptLineNumber)" $ErrorColor
    exit 1
}
finally {
    Write-ColoredOutput "üèÅ Script finalizado" $InfoColor
    Set-Location $RootPath
} 
/**
 * Tests Unitarios - Servicios
 * Suite completa para servicios cr√≠ticos del sistema
 * 
 * @author DevOps Senior - TeamLens Testing Suite
 * @version 1.0.0
 * 
 * FUNCIONALIDADES TESTEADAS:
 * - Servicio de base de datos (conexi√≥n, collections)
 * - Servicio de email (env√≠o, validaciones, templates)
 * - Manejo de errores en servicios
 * - Configuraciones de entorno
 */

import { MongoClient } from 'mongodb';
import { connectToDatabase, collections, client } from '../../src/services/database.service';

// Mock del servicio de email completo
jest.mock('nodemailer', () => ({
  createTransporter: jest.fn().mockReturnValue({
    sendMail: jest.fn().mockResolvedValue({
      messageId: 'test-message-id',
      accepted: ['test@teamlens.com'],
      rejected: [],
      response: '250 Message accepted'
    }),
    verify: jest.fn().mockResolvedValue(true)
  })
}));

import emailService from '../../src/services/email.service';

describe('üîß Services - Tests Unitarios de Servicios', () => {

  /**
   * Tests del Servicio de Base de Datos
   */
  describe('üíæ Database Service', () => {
    
    it('‚úÖ Debe conectar a la base de datos exitosamente', async () => {
      // La conexi√≥n ya deber√≠a estar establecida por el setup global
      expect(collections.users).toBeDefined();
      expect(collections.activities).toBeDefined();
      expect(collections.groups).toBeDefined();
      expect(collections.questionnaires).toBeDefined();

      console.log('‚úÖ [Services Tests] Conexi√≥n a base de datos verificada');
    });

    it('‚úÖ Debe tener todas las colecciones configuradas', async () => {
      // Verificar que todas las colecciones esperadas est√©n disponibles
      const expectedCollections = ['users', 'activities', 'groups', 'questionnaires'];
      
      for (const collectionName of expectedCollections) {
        expect(collections[collectionName as keyof typeof collections]).toBeDefined();
      }

      console.log('‚úÖ [Services Tests] Configuraci√≥n de colecciones verificada');
    });

    it('‚úÖ Debe permitir operaciones CRUD b√°sicas', async () => {
      // Test de inserci√≥n
      const testDocument = {
        email: 'dbtest@teamlens.test',
        name: 'DB Test User',
        password: 'hashedpassword',
        role: 'student'
      };

      const insertResult = await collections.users?.insertOne(testDocument);
      expect(insertResult?.insertedId).toBeDefined();

      // Test de b√∫squeda
      const foundDocument = await collections.users?.findOne({ 
        _id: insertResult!.insertedId 
      });
      expect(foundDocument?.email).toBe(testDocument.email);

      // Test de actualizaci√≥n
      const updateResult = await collections.users?.updateOne(
        { _id: insertResult!.insertedId },
        { $set: { name: 'Updated Name' } }
      );
      expect(updateResult?.modifiedCount).toBe(1);

      // Test de eliminaci√≥n
      const deleteResult = await collections.users?.deleteOne({ 
        _id: insertResult!.insertedId 
      });
      expect(deleteResult?.deletedCount).toBe(1);

      console.log('‚úÖ [Services Tests] Operaciones CRUD b√°sicas verificadas');
    });

    it('‚ùå Debe manejar errores de operaciones de DB', async () => {
      // Intentar insertar documento con estructura inv√°lida para MongoDB
      try {
        await collections.users?.insertOne(null as any);
        expect(true).toBe(false); // No deber√≠a llegar aqu√≠
      } catch (error) {
        expect(error).toBeDefined();
      }

      console.log('‚úÖ [Services Tests] Manejo de errores de DB verificado');
    });

    it('‚úÖ Debe manejar operaciones con √≠ndices y b√∫squedas complejas', async () => {
      // Insertar m√∫ltiples documentos para test de b√∫squeda
      const testUsers = [
        { email: 'user1@test.com', name: 'User 1', role: 'student', password: 'hash1' },
        { email: 'user2@test.com', name: 'User 2', role: 'teacher', password: 'hash2' },
        { email: 'user3@test.com', name: 'User 3', role: 'student', password: 'hash3' }
      ];

      const insertResults = await collections.users?.insertMany(testUsers);
      expect(insertResults?.insertedCount).toBe(3);

      // B√∫squeda por rol
      const students = await collections.users?.find({ role: 'student' }).toArray();
      expect(students?.length).toBeGreaterThanOrEqual(2);

      // B√∫squeda con proyecci√≥n
      const emailsOnly = await collections.users?.find(
        { role: 'student' },
        { projection: { email: 1, _id: 0 } }
      ).toArray();
      
      expect(emailsOnly?.every(doc => doc.email && !doc.name)).toBe(true);

      // Limpiar datos de test
      await collections.users?.deleteMany({ 
        email: { $in: testUsers.map(u => u.email) } 
      });

      console.log('‚úÖ [Services Tests] Operaciones complejas de DB verificadas');
    });
  });

  /**
   * Tests del Servicio de Email
   */
  describe('üìß Email Service', () => {
    
    it('‚úÖ Debe enviar email b√°sico exitosamente', async () => {
      const mailDetails = {
        to: 'test@teamlens.test',
        subject: 'Test Email',
        text: 'This is a test email'
      };

      const result = await emailService.sendEmail(mailDetails);

      expect(result.success).toBe(true);
      expect(result.messageId).toBeDefined();

      console.log('‚úÖ [Services Tests] Env√≠o de email b√°sico verificado');
    });

    it('‚úÖ Debe enviar email con HTML exitosamente', async () => {
      const mailDetails = {
        to: 'htmltest@teamlens.test',
        subject: 'HTML Test Email',
        html: '<h1>Test HTML Email</h1><p>This is a test email with HTML</p>'
      };

      const result = await emailService.sendEmail(mailDetails);

      expect(result.success).toBe(true);
      expect(result.messageId).toBeDefined();

      console.log('‚úÖ [Services Tests] Env√≠o de email HTML verificado');
    });

    it('‚úÖ Debe enviar invitaci√≥n de estudiante con template profesional', async () => {
      const studentEmail = 'invite@teamlens.test';
      const invitationToken = 'test-invitation-token';

      const result = await emailService.sendStudentInvitation(studentEmail, invitationToken);

      expect(result.success).toBe(true);
      expect(result.messageId).toBeDefined();

      console.log('‚úÖ [Services Tests] Env√≠o de invitaci√≥n de estudiante verificado');
    });

    it('‚ùå Debe rechazar email sin destinatario', async () => {
      const invalidMailDetails = {
        subject: 'Test Email',
        text: 'This email has no recipient'
        // Falta 'to'
      };

      const result = await emailService.sendEmail(invalidMailDetails as any);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Destinatario (to) es requerido');

      console.log('‚úÖ [Services Tests] Rechazo por falta de destinatario verificado');
    });

    it('‚ùå Debe rechazar email sin asunto', async () => {
      const invalidMailDetails = {
        to: 'test@teamlens.test',
        text: 'This email has no subject'
        // Falta 'subject'
      };

      const result = await emailService.sendEmail(invalidMailDetails as any);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Asunto (subject) es requerido');

      console.log('‚úÖ [Services Tests] Rechazo por falta de asunto verificado');
    });

    it('‚ùå Debe rechazar email sin contenido', async () => {
      const invalidMailDetails = {
        to: 'test@teamlens.test',
        subject: 'Test Email'
        // Falta 'text' o 'html'
      };

      const result = await emailService.sendEmail(invalidMailDetails as any);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Contenido del email (text o html) es requerido');

      console.log('‚úÖ [Services Tests] Rechazo por falta de contenido verificado');
    });

    it('‚úÖ Debe usar configuraci√≥n por defecto para remitente', async () => {
      const mailDetails = {
        to: 'defaultfrom@teamlens.test',
        subject: 'Default From Test',
        text: 'Testing default from configuration'
        // Sin especificar 'from'
      };

      const result = await emailService.sendEmail(mailDetails);

      expect(result.success).toBe(true);
      // El servicio deber√≠a usar el from por defecto configurado

      console.log('‚úÖ [Services Tests] Configuraci√≥n por defecto de remitente verificada');
    });

    it('‚úÖ Debe manejar m√∫ltiples destinatarios', async () => {
      const mailDetails = {
        to: ['recipient1@teamlens.test', 'recipient2@teamlens.test'],
        subject: 'Multiple Recipients Test',
        text: 'Testing multiple recipients'
      };

      const result = await emailService.sendEmail(mailDetails);

      expect(result.success).toBe(true);

      console.log('‚úÖ [Services Tests] M√∫ltiples destinatarios verificados');
    });

    it('‚úÖ Debe incluir informaci√≥n de debug en desarrollo', async () => {
      // Forzar modo desarrollo
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'development';

      const mailDetails = {
        to: 'debug@teamlens.test',
        subject: 'Debug Test',
        text: 'Testing debug information'
      };

      const result = await emailService.sendEmail(mailDetails);

      expect(result.success).toBe(true);
      expect(result.debugInfo).toBeDefined();

      // Restaurar entorno original
      process.env.NODE_ENV = originalEnv;

      console.log('‚úÖ [Services Tests] Informaci√≥n de debug verificada');
    });
  });

  /**
   * Tests de Configuraci√≥n y Variables de Entorno
   */
  describe('‚öôÔ∏è Configuraci√≥n de Servicios', () => {
    
    it('‚úÖ Debe usar variables de entorno de testing', async () => {
      // Verificar que las variables de entorno de test est√°n configuradas
      expect(process.env.NODE_ENV).toBe('test');
      expect(process.env.JWT_SECRET).toBeDefined();
      expect(process.env.MONGO_URI).toBeDefined();
      expect(process.env.DB_NAME).toBe('teamlens_test');

      console.log('‚úÖ [Services Tests] Variables de entorno de testing verificadas');
    });

    it('‚úÖ Debe manejar configuraci√≥n de email para testing', async () => {
      // Verificar configuraci√≥n de email para testing
      expect(process.env.EMAIL_USER).toBe('test@teamlens.com');
      expect(process.env.FRONTEND_URL).toBe('http://localhost:4200');

      console.log('‚úÖ [Services Tests] Configuraci√≥n de email para testing verificada');
    });

    it('‚ùå Debe manejar variables de entorno faltantes graciosamente', async () => {
      // Simular variable de entorno faltante
      const originalJwtSecret = process.env.JWT_SECRET;
      delete process.env.JWT_SECRET;

      // El sistema deber√≠a usar valores por defecto o manejar el error
      // En este caso, el servicio usa un valor por defecto
      
      // Restaurar variable original
      process.env.JWT_SECRET = originalJwtSecret;

      console.log('‚úÖ [Services Tests] Manejo de variables faltantes verificado');
    });
  });

  /**
   * Tests de Performance y Reliability
   */
  describe('‚ö° Performance y Reliability', () => {
    
    it('‚úÖ Debe manejar m√∫ltiples conexiones de DB concurrentes', async () => {
      // Crear m√∫ltiples operaciones de DB concurrentes
      const operations = [];
      const numberOfOperations = 10;

      for (let i = 0; i < numberOfOperations; i++) {
        const operation = collections.users?.findOne({ role: 'student' });
        operations.push(operation);
      }

      const results = await Promise.all(operations);

      // Todas las operaciones deber√≠an completarse sin error
      expect(results).toHaveLength(numberOfOperations);

      console.log('‚úÖ [Services Tests] Conexiones concurrentes de DB verificadas');
    });

    it('‚úÖ Debe manejar m√∫ltiples env√≠os de email concurrentes', async () => {
      const emailPromises = [];
      const numberOfEmails = 5;

      for (let i = 0; i < numberOfEmails; i++) {
        const mailDetails = {
          to: `concurrent${i}@teamlens.test`,
          subject: `Concurrent Email ${i}`,
          text: `This is concurrent email number ${i}`
        };
        emailPromises.push(emailService.sendEmail(mailDetails));
      }

      const results = await Promise.all(emailPromises);

      // Todos los emails deber√≠an enviarse exitosamente
      expect(results).toHaveLength(numberOfEmails);
      expect(results.every(result => result.success)).toBe(true);

      console.log('‚úÖ [Services Tests] Env√≠os concurrentes de email verificados');
    });

    it('‚úÖ Debe mantener performance con operaciones grandes', async () => {
      // Test de performance con inserci√≥n masiva
      const largeDataSet = [];
      const numberOfDocuments = 100;

      for (let i = 0; i < numberOfDocuments; i++) {
        largeDataSet.push({
          email: `bulk${i}@teamlens.test`,
          name: `Bulk User ${i}`,
          password: 'hashedpassword',
          role: 'student'
        });
      }

      const startTime = Date.now();
      const insertResult = await collections.users?.insertMany(largeDataSet);
      const endTime = Date.now();

      expect(insertResult?.insertedCount).toBe(numberOfDocuments);
      expect(endTime - startTime).toBeLessThan(5000); // Menos de 5 segundos

      // Limpiar datos de test
      await collections.users?.deleteMany({ 
        email: { $regex: /^bulk\d+@teamlens\.test$/ } 
      });

      console.log('‚úÖ [Services Tests] Performance con operaciones grandes verificada');
    });
  });

  /**
   * Tests de Integridad y Consistencia
   */
  describe('üîÑ Integridad y Consistencia', () => {
    
    it('‚úÖ Debe mantener consistencia en transacciones complejas', async () => {
      // Simular operaci√≥n compleja que requiere consistencia
      const testUser = {
        email: 'consistency@teamlens.test',
        name: 'Consistency User',
        password: 'hashedpassword',
        role: 'student'
      };

      // Insertar usuario
      const userResult = await collections.users?.insertOne(testUser);
      const userId = userResult!.insertedId;

      // Crear actividad relacionada
      const testActivity = {
        title: 'Consistency Activity',
        description: 'Testing consistency',
        teacher: userId,
        students: [userId],
        groups: []
      };

      const activityResult = await collections.activities?.insertOne(testActivity);

      // Verificar que ambas operaciones fueron exitosas
      expect(userResult?.insertedId).toBeDefined();
      expect(activityResult?.insertedId).toBeDefined();

      // Verificar integridad referencial
      const createdUser = await collections.users?.findOne({ _id: userId });
      const createdActivity = await collections.activities?.findOne({ teacher: userId });

      expect(createdUser).toBeDefined();
      expect(createdActivity).toBeDefined();
      expect(createdActivity?.students).toContain(userId);

      // Limpiar datos de test
      await collections.users?.deleteOne({ _id: userId });
      await collections.activities?.deleteOne({ _id: activityResult!.insertedId });

      console.log('‚úÖ [Services Tests] Consistencia en transacciones complejas verificada');
    });
  });

  /**
   * Cleanup despu√©s de todos los tests
   */
  afterAll(async () => {
    console.log('üßπ [Services Tests] Limpiando recursos...');
    
    // Limpiar cualquier dato de test que pueda haber quedado
    if (collections.users) {
      await collections.users.deleteMany({ 
        email: { $regex: /test\.com$|teamlens\.test$/ } 
      });
    }
    
    console.log('‚úÖ [Services Tests] Tests de servicios completados');
  });
}); 